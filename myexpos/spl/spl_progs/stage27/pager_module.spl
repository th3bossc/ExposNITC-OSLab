// // Pager module (MOD 6)

// alias fnNum R1;
// alias pid R2;

// if(R1 == SWAP_OUT) then
//   alias i R3;
//   i = 3;
//   alias procTab R4;
//   alias reqpid R5;
//   alias condn R6;
//   condn = WAIT_PROCESS;

// findproc:
//   while(i< MAX_PROC_NUM) do
//     procTab = PROCESS_TABLE + 16*i;
//     if([procTab + 4] == condn && [procTab + 6]!=1) then
//       reqpid = i;
//       break;
//     endif;
//   i = i + 1;
//   endwhile;
  
//   if(i == MAX_PROC_NUM && condn == WAIT_PROCESS) then
//     condn = WAIT_SEMAPHORE;
//     goto findproc;
//   endif;
//   if(i == MAX_PROC_NUM && condn == WAIT_SEMAPHORE) then
//     i = 3;
//     reqpid = -1;
//     alias maxtick R7;
//     maxtick = -1;

//     while(i<MAX_PROC_NUM) do
//       procTab = PROCESS_TABLE + 16*i;
//       if([procTab] > maxtick && [procTab + 4] != ALLOCATED && [procTab + 4] != RUNNING && [procTab + 4] != TERMINATED && [procTab + 6] != 1) then
// 	maxtick = [procTab];
// 	reqpid = i;
//       endif;
//      i = i + 1;
//      endwhile;
//     endif;

//    if(reqpid == -1) then
//      [SYSTEM_STATUS_TABLE + 5] = 0;
//      return;
//    endif;

//    procTab = PROCESS_TABLE + 16*reqpid;
//    [procTab] = 0;
//    alias pt R7;
//    pt = [procTab + 14];
//    i = 2;
//    while(i<MAX_PROC_PAGES) do
//      if(i>3 && i<8) then
//      if([pt + 2*i] != -1) then
     
//      multipush(R1, R2, R3, R4, R5, R6, R7);
//      R1 = RELEASE_PAGE;
//      R2 = [pt + 2*i];
//      call MEMORY_MANAGER;
//      multipop(R1, R2, R3, R4, R5, R6, R7);
//      endif;
//      [pt + 2*i] = -1;
//      [pt + 2*i + 1] = "0000";
//      endif;

//      if((i>1 && i<4) || (i>7 && i<10)) then
//      if([pt + 2*i] != -1 && [MEMORY_FREE_LIST + [pt + 2*i]] <2) then	
//        call getswpblk;
//        [DISK_MAP_TABLE + 10*reqpid + i] = R0;
//        multipush(R1, R2, R3, R4, R5, R6, R7);
//        R1 = DISK_STORE;
//        R2 = pid;
//        R3 = [pt + 2*i];
//        R4 = R0;
//        call DEVICE_MANAGER;
//        multipop(R1, R2, R3, R4, R5, R6, R7);
//        multipush(R1, R2, R3, R4, R5, R6, R7);
//        R1 = RELEASE_PAGE;
//        R2 = [pt + 2*i];
//        call MEMORY_MANAGER;
//        multipop(R1, R2, R3, R4, R5, R6, R7);
//        [pt + 2*i] = -1;
//        [pt + 2*i + 1] = "0000";
//      endif;
//      endif;
//   i = i + 1;
//   endwhile; 

//   [procTab + 6] = 1;
//   breakpoint;
//   [SYSTEM_STATUS_TABLE + 4] = [SYSTEM_STATUS_TABLE + 4] + 1;
//   [SYSTEM_STATUS_TABLE + 5] = 0;
//   return;
// endif;


// if(fnNum == SWAP_IN) then
//   alias i R3;
//   i = 0;
//   alias procTab R4;
//   alias reqpid R5;
//   reqpid = -1;
//   alias maxtick R6;
//   maxtick = -1;
//   while(i<MAX_PROC_NUM) do
//      procTab = PROCESS_TABLE + 16*i;
//      if([procTab] > maxtick && [procTab + 4] == READY && [procTab + 6] == 1) then
//        reqpid = i;
//        break;
//      endif;
//   i = i + 1;
//   endwhile;

//   if(reqpid == -1) then
//     [SYSTEM_STATUS_TABLE + 5] = 0;
//     return;
//   endif;

//   procTab = PROCESS_TABLE + 16*reqpid;
//   [procTab] = 0;
//   alias pt R7;
//   pt = [procTab + 14];
//   i = 2;

//   while(i<MAX_PROC_PAGES) do
//     if(i>1 && i<4) then
//       if([DISK_MAP_TABLE + 10*reqpid + i] != -1) then
//         call getFreepage;

// 	[pt + 2*i] = R0;
// 	[pt + 2*i + 1] = "0110";
// 	call diskload;
// 	call relblock;
// 	[DISK_MAP_TABLE + 10*reqpid + i] = -1;

//       endif; 

//     endif;
//     if(i > 7 && i <10) then
//       call getFreepage;
//       [pt + 2*i] = R0;
//       [pt + 2*i + 1] = "0110";
//       call diskload;
//       call relblock;
//       [DISK_MAP_TABLE + 10*reqpid + i] = -1;
//     endif;

//   i = i + 1;
//   endwhile;
//   [procTab + 6] = 0;
//   [SYSTEM_STATUS_TABLE + 4] = [SYSTEM_STATUS_TABLE + 4] - 1;
//   [SYSTEM_STATUS_TABLE + 5] = 0;
//   return;

// endif;

// getFreepage:
// 	multipush(R1, R2, R3, R4, R5, R6, R7);
// 	R1 = GET_FREE_PAGE;
// 	call MEMORY_MANAGER;
// 	multipop(R1, R2, R3, R4, R5, R6, R7);
// return;

// relblock:
//         multipush(R1, R2, R3, R4, R5, R6, R7);
// 	R1 = RELEASE_BLOCK;
// 	R2 = [DISK_MAP_TABLE + 10*R5+ R3];
// 	call MEMORY_MANAGER;
// 	multipop(R1, R2, R3, R4, R5, R6, R7);
// 	return;

// diskload:
// 	multipush(R1, R2, R3, R4, R5, R6, R7);
// 	R4 = [DISK_MAP_TABLE + 10*R5 + R3];
// 	R1 = DISK_LOAD;
// 	R2 = pid;
// 	R3 = R0;
// 	call DEVICE_MANAGER;
//         multipop(R1, R2, R3, R4, R5, R6, R7);
// 	return;

// getswpblk:
//        multipush(R1, R2, R3, R4, R5, R6, R7);
// 	R1 = GET_SWAP_BLOCK;
// 	call MEMORY_MANAGER;
// 	multipop(R1, R2, R3, R4, R5, R6, R7);
//         return;

// breakpoint;
alias functionNum R1;
alias currentPID R2;

if (functionNum == SWAP_OUT) then
    alias counter R5;
    counter = 3;

    alias waitSemPID R10;
    waitSemPID = -1;
    
    alias maxTickPID R11;
    maxTickPID = -1;

    alias maxTICK R12;
    maxTICK = -1;

    alias swapPID R3;
    swapPID = -1;
    while (counter < MAX_PROC_NUM - 1) do
        if ([PROCESS_TABLE + counter*16 + 6] == 0) then
            if ([PROCESS_TABLE + counter*16 + 4] == WAIT_PROCESS) then
                swapPID = counter;
                break;
            endif;
            if (waitSemPID == -1 && [PROCESS_TABLE + counter*16 + 4] == WAIT_SEMAPHORE) then
                waitSemPID = counter;
            endif;

            alias tempPCB R13;
            tempPCB = PROCESS_TABLE + counter*16;
            if ([tempPCB+4] != TERMINATED && [tempPCB+4] != ALLOCATED && [tempPCB] != RUNNING) then
                if ([tempPCB] > maxTICK) then
                    maxTICK = [tempPCB];
                    maxTickPID = counter;
                endif;
            endif;
        endif;
        counter = counter + 1;
    endwhile;

    if (swapPID == -1) then
        if (waitSemPID != -1) then
            swapPID = waitSemPID;
        else
            swapPID = maxTickPID;
        endif;
    endif;

    if (swapPID == -1) then
        [SYSTEM_STATUS_TABLE+5] = 0;
        R0 = -1;
        // breakpoint;
        return;
    endif;

    [PROCESS_TABLE + swapPID*16] = 0;

    alias swapPTBR R4;
    swapPTBR = [PROCESS_TABLE + swapPID*16 + 14];

    counter = 4;
    while (counter < 20) do
        alias pageNumber R6;
        pageNumber = [swapPTBR + counter];

        // heap pages or stack pages
        if (counter <= 6 || counter >= 16) then
            if (pageNumber != -1 && [MEMORY_FREE_LIST + pageNumber] == 1) then
                multipush (R1, R2, R3, R4, R5, R6);
                R1 = GET_SWAP_BLOCK;
                call MEMORY_MANAGER;
                multipop  (R1, R2, R3, R4, R5, R6);

                [DISK_MAP_TABLE + 10*swapPID + (counter/2)] = R0;

                multipush (R1, R2, R3, R4, R5, R6);
                R1 = DISK_STORE;
                R2 = SWAPPER_DAEMON;
                R3 = pageNumber;
                R4 = R0;
                call DEVICE_MANAGER;
                multipop  (R1, R2, R3, R4, R5, R6);
            endif;
        endif;

        if (pageNumber != -1) then
            multipush (R1, R3, R3, R5);
            R1 = RELEASE_PAGE;
            R2 = pageNumber;
            call MEMORY_MANAGER;
            multipop  (R1, R3, R3, R5);
        endif;

        [swapPTBR + counter] = -1;
        [swapPTBR + counter + 1] = "0000";

        counter = counter + 2;
    endwhile;

    [PROCESS_TABLE + swapPID*16 + 6] = 1;

    [SYSTEM_STATUS_TABLE+4] = [SYSTEM_STATUS_TABLE+4] + 1;
    [SYSTEM_STATUS_TABLE+5] = 0;

    // print "swap out";
    // print swapPID;

    // breakpoint;
    return;
endif;

if (functionNum == SWAP_IN) then
    alias counter R5;
    counter = 3;

    alias swapPID R3;
    swapPID = -1;
    alias maxTICK R10;
    maxTICK = 0;
    while (counter < MAX_PROC_NUM - 1) do
        if ([PROCESS_TABLE + counter*16 + 6] == 1 && [PROCESS_TABLE + counter*16 + 4] == READY) then
            if ([PROCESS_TABLE + counter*16] > maxTICK) then
                swapPID = counter;
                maxTICK = [PROCESS_TABLE + counter*16];
            endif;
        endif;
        counter = counter + 1;
    endwhile;

    if (swapPID == -1) then
        [SYSTEM_STATUS_TABLE+5] = 0;
        R0 = -1;
        // breakpoint;
        return;
    endif;

    [PROCESS_TABLE + swapPID*16] = 0;

    alias swapPTBR R4;
    swapPTBR = [PROCESS_TABLE + swapPID*16 + 14];

    counter = 4;
    while (counter < 20) do
        if (counter >= 8 && counter < 16) then
            counter = counter + 2;
            continue;
        endif;

        alias blockNumber R6;
        blockNumber = [DISK_MAP_TABLE + swapPID*10 + (counter/2)];

        if (blockNumber != -1) then
            multipush (R1, R2, R3, R4, R5, R6);
            R1 = GET_FREE_PAGE;
            call MEMORY_MANAGER;
            multipop  (R1, R2, R3, R4, R5, R6);

            [swapPTBR + counter] = R0;
            [swapPTBR + counter + 1] = "0110";
            if (counter >= 8 && counter < 16) then
                [swapPTBR + counter + 1] = "0100";
            endif;

            multipush (R1, R2, R3, R4, R5, R6);
            R1 = DISK_LOAD;
            R2 = SWAPPER_DAEMON;
            R3 = R0;
            R4 = blockNumber;
            call DEVICE_MANAGER;
            multipop  (R1, R2, R3, R4, R5, R6);

            multipush (R1, R2, R3, R4, R5, R6);
            R1 = RELEASE_BLOCK;
            R2 = blockNumber;
            R3 = SWAPPER_DAEMON;
            call MEMORY_MANAGER;
            multipop   (R1, R2, R3, R4, R5, R6);

            [DISK_MAP_TABLE + swapPID*10 + (counter/2)] = -1;
        endif;
        counter = counter + 2;
    endwhile;

    [PROCESS_TABLE + swapPID*16 + 6] = 0;

    [SYSTEM_STATUS_TABLE+4] = [SYSTEM_STATUS_TABLE+4] - 1;
    [SYSTEM_STATUS_TABLE+5] = 0;

    // print "swap in";
    // print swapPID;

    // breakpoint;
    return;
endif;