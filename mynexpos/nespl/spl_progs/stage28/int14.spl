alias userSP R1;
userSP = SP;

alias currPID R2;
currPID = [SYSTEM_STATUS_TABLE + CORE*5 + 1];

alias procTab R3;
procTab = PROCESS_TABLE + 16*currPID;

alias syscall R4;
syscall = [[PTBR + 2*(userSP-5)/512]*512 + (userSP-5)%512];

[procTab + 9] = syscall;
[procTab + 13] = SP;
SP = [procTab + 11]*512 -1;

multipush(R1, R2, R3, R4);
R1 = ACQUIRE_KERN_LOCK;
call ACCESS_CONTROL;
multipop(R1, R2, R3, R4);

if(syscall == 19) then
    alias semid R5;
    alias resTab R6;
    resTab = ([procTab+11])*512 + RESOURCE_TABLE_OFFSET;
    breakpoint;
    semid = [[PTBR + 2*(userSP-4)/512]*512 + (userSP-4)%512];
    if(semid<0 || semid>7 || [resTab + 2*semid] != SEMAPHORE) then

        multipush(R1, R2, R3, R4);
        R1 = RELEASE_LOCK;
        R2 = KERN_LOCK;
        call ACCESS_CONTROL;
        multipop(R1, R2, R3, R4);

        [[PTBR + 2*(userSP-1)/512]*512 + (userSP-1)%512] = -1;
        SP = userSP;
        [procTab + 9] = 0;
        ireturn;
    endif;
    
    alias semind R7;
    semind = [resTab + 2*semid + 1];
    while([SEMAPHORE_TABLE + semind*4] != -1 && [SEMAPHORE_TABLE + semind*4] != currPID) do
        [procTab + 4] = WAIT_SEMAPHORE;
        [procTab + 5] = semind;
        multipush(R1, R2, R3, R4, R5, R6, R7);
        breakpoint;
        R1 = RELEASE_LOCK;
        R2 = KERN_LOCK;
        call ACCESS_CONTROL;
        call MOD_5;
        multipop(R1, R2, R3, R4, R5, R6, R7);
    endwhile;
    [SEMAPHORE_TABLE + semind*4] = currPID;

    multipush(R1, R2, R3, R4);
    R1 = RELEASE_LOCK;
    R2 = KERN_LOCK;
    call ACCESS_CONTROL;
    multipop(R1 ,R2, R3 , R4);

    [procTab + 9] = 0;
    SP = userSP;
    [[PTBR + 2*(userSP-1)/512]*512 + (userSP-1)%512] = 0;
    ireturn;
endif;

if(syscall == 20) then
    alias semid R5; 
    alias resTab R6;
    resTab = ([procTab+11]+1)*512 - 16;
    semid = [[PTBR + 2*(userSP-4)/512]*512 + (userSP-4)%512];
    if(semid<0 || semid>7 || [resTab + 2*semid] != 1) then
        multipush(R1, R2, R3, R4);
        R1 = RELEASE_LOCK;
        R2 = KERN_LOCK;
        call ACCESS_CONTROL;
        multipop(R1, R2, R3, R4);

        [[PTBR + 2*(userSP-1)/512]*512 + (userSP-1)%512] = -1;
        SP = userSP;
        [procTab + 9] = 0;
        ireturn;
    endif;
    
    alias semind R7;
    semind = [resTab + 2*semid + 1];
    if([SEMAPHORE_TABLE+ 4*semind] != -1) then
        if([SEMAPHORE_TABLE + 4*semind] != currPID) then 

        
        multipush(R1, R2, R3, R4);
        R1 = RELEASE_LOCK;
        R2 = KERN_LOCK;
        call ACCESS_CONTROL;
        multipop(R1, R2, R3, R4);

        [[PTBR + 2*(userSP-1)/512]*512 + (userSP-1)%512] = -2;
        SP = userSP;
        [procTab + 9] = 0;
        ireturn;
        endif;
        [SEMAPHORE_TABLE + 4*semind] = -1;
        alias i R8;
        i = 1;
        while(i<16) do
            alias procTable R9;
            procTable = PROCESS_TABLE + 16*i;
            if([procTable + 4] == WAIT_SEMAPHORE && [procTable + 5] == semind) then
            [procTable + 4] = READY;
            [procTable + 5] = -1;
            endif;
            i = i + 1;
        endwhile;
    endif;


    multipush(R1, R2, R3, R4);
    R1 = RELEASE_LOCK;
    R2 = KERN_LOCK;
    call ACCESS_CONTROL;
    multipop(R1, R2, R3, R4);

    [procTab + 9] = 0;
    SP = userSP; 
    [[PTBR + 2*(userSP-1)/512]*512 + (userSP-1)%512] = 0;
    ireturn;
endif;